% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/model-utils.r
\name{transpile_to_cpp}
\alias{transpile_to_cpp}
\title{Transpile R Function to C++ Code}
\usage{
transpile_to_cpp(
  g_fun,
  function_name = "g_scalar_cpp",
  is_main = TRUE,
  hierarchy_path = NULL
)
}
\arguments{
\item{g_fun}{A function object to be transpiled to C++}

\item{function_name}{Character string specifying the name of the C++
function.
Defaults to "g_scalar_cpp"}

\item{is_main}{Logical. If TRUE, adds Rcpp::export attribute to the function.
Defaults to TRUE}

\item{hierarchy_path}{Character string representing the current position in
the function hierarchy for nested function naming. Used internally for
recursive calls. Defaults to NULL}
}
\value{
A character string containing the complete transpiled C++ function
code, including function signature, variable declarations, translated
expressions, and any auxiliary functions
}
\description{
Converts an R function into equivalent C++ code that can be used with Rcpp.
Supports mathematical functions, control flow structures, and recursive
transpilation of nested functions.
}
\details{
The function supports:
\itemize{
\item Mathematical functions (exp, log, sin, cos, etc.)
\item Binary operators (+, -, *, /, ^, ==, <, >, &&, ||, etc.)
\item Unary operators (-, +, !)
\item Control flow (if/else, for loops, while loops)
\item Variable declarations and assignments
\item Function calls and nested function transpilation
\item Vector indexing with automatic 1-to-0-based conversion
\item Type inference for environment variables
}

Warnings are accumulated during transpilation and reported to the user
for unsupported constructs or automatic conversions.
}
\examples{
\dontrun{
# Simple scalar function
f <- function(x, y) {
  z <- x + y
  return(exp(z))
}
cpp_code <- transpile_to_cpp(f, "my_function")
cat(cpp_code)
}

}
\keyword{internal}
