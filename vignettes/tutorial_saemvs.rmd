---
title: "A quick tutorial on SAEMVS"
author: "Maud Delattre"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 2
    number_sections: true
vignette: >
  %\VignetteIndexEntry{A quick tutorial on SAEMVS}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
library(saemvs)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  echo = TRUE, # montre le code
  results = "markup", # montre les sorties console
  message = TRUE, # garde les messages R
  warning = FALSE, # garde les warnings
  fig.show = "hold", # affiche les graphiques
  fig.align = "center",
  fig.width = 6,
  fig.height = 4
)
```

# Introduction

The **`saemvs`** package is designed for users of nonlinear mixed-effects models who want to perform variable selection, especially when the number of available covariates is very large (high-dimensional variable selection).

`saemvs` implements the first algorithm that performs this task in an automatic way, unlike existing methods that are largely empirical or manual.

The package leverages `C++` code via `Rcpp` to ensure efficient computation even for high-dimensional data.

The results shown in this vignette rely on pre-computed objects
stored as `.rds` files. Recomputing these results would take several
minutes and is therefore not run during package checks.

# Installation

To use the `saemvs` package, first ensure it is installed. Once installed, load the package with:

```{r}
library(saemvs)
```

# Getting started

The package includes one example dataset used throughout this vignette to illustrate the main functionalities of `saemvs`.

```{r}
library(saemvs)
data("df_long")
data("df_cov")
```

- `df_long`: stores the longitudinal observations with columns `id`, `time`, and `y`.
- `df_cov`: contains the simulated covariates for each individual (one row per individual, one column per covariate).

To use data with `saemvs`, you first need to merge observations and covariates into a single data frame:

```{r}
full_data <- merge(df_long, df_cov, by = "id")
```

This combined data frame can then be used to create a `saemvsData` object, which is the format expected by most functions in the package.

The simulated dataset represents a simple growth model, where the response trajectories mimic individual growth curves over time.
Each individual is associated with 50 simulated candidate covariates, among which only a few have an actual effect on the model parameters.
These datasets are designed to provide realistic test cases for illustrating variable selection with `saemvs`. Users interested in the generation procedure can find the script in `inst/scripts`.

## Preparation

First, it is necessary to specify the data structure, the model, and various settings that are useful for running the SAEMVS procedure.

The `saemvsData` object contains the observed responses (`y`), the measurement time points (`t`) and the candidate covariates for variable selection. This object serves as the main input for the SAEMVS algorithm and is created using the function `saemvsData_from_df`

```{r}
# Create saemvsData object from dataframes
saemvs_input <- saemvsData_from_df(
  formula = as.formula("y ~ . + repeated(time) + group(id)"),
  data = full_data
)
```

Here:

- `y ~ .` specifies that `y` is the response and all other columns in `full_data` (except `id` and `time`) are candidate covariates.

- `repeated(time)` tells the function that measurements are repeated over time.

- `group(id)` identifies the individual subjects.

The `saemvsModel` object specifies the structural model. For this example, we consider a 3-parameter logistic-type model.

```{r}
# Define the model function
g <- function(t, a, b, c) {
  b + a / (1 + exp(-(t - c)))
}

# Create saemvsModel object
model <- saemvsModel(
  g = g,
  phi_to_select = c("a", "c")
)
```

`g` is the user-defined model function. The first argument must always represent time (or more generally the repeated measurement factor), while the subsequent arguments correspond to the model parameters, on which variable selection can optionally be performed. `phi_to_select` lists the names of the parameters on which variable selection will be performed (here `a` and `c`). 

The minimum hyperparameters to be declared in the object are those of the inverse Wishart distribution on the covariance matrix of random effects (*i.e* its scale matrix `cov_re_prior_scale` and degrees of freedom `cov_re_prior_df`.).

```{r}
# Define hyperparameters for the slab
hyper_slab <- saemvsHyperSlab(
  cov_re_prior_scale = diag(rep(0.2, 2)),
  cov_re_prior_df = 4
)
```

The `saemvsTuning` object specifies algorithm tuning parameters, here 

- `niter`: total number of iterations,
- `nburnin`: number of burn-in iterations,
- `spike_values_grid`: grid of spike values for variable selection.

```{r}
# Define tuning parameters
tuning <- saemvsTuning(
  niter = 1000,
  nburnin = 800,
  spike_values_grid = exp(-3 + seq(3, 10) * 3 / 4)
)
```

Finally, the `saemvsInit` object specifies initial values for the algorithm.

```{r}
# Define initial values
init_values <- saemvsInit(
  intercept = c(1300, 350, 250),
  beta_candidates = matrix(
    c(
      80, 20, 20, rep(0, 47),
      rep(0, 50),
      15, rep(0, 49)
    ),
    ncol = 3
  ),
  cov_re = diag(c(400, 200, 200)),
  sigma2 = 100
)
```

## Running SAEMVS

Once all objects are prepared (`saemvsData`, `saemvsModel`, `saemvsHyperSlab`, `saemvsTuning`, `saemvsInit`), you can run the main `saemvs` function to perform variable selection.

```{r run_saemvs, eval = FALSE}
# Run the SAEMVS algorithm
result <- saemvs(
  data = saemvs_input,
  model = model,
  init = init_values,
  tuning_algo = tuning,
  hyperparam = hyper_slab
)
```

## Inspect the results

After running the SAEMVS procedure, you can inspect the selected variables and the estimated parameters.

```{r load_result, include = FALSE}
result <- readRDS(system.file(
  "extdata", "result_basic_example.rds", package = "saemvs"
))
```

You can get a summary of the selected variables and parameter estimates using the `summary()` function, which gives an overview of the parameters selected by the procedure and their estimated values in the best model.

```{r saemvs_summary}
summary(result)
```

The SAEMVS procedure explores multiple supports (combinations of selected variables). You can inspect each visited support using `summary_support(result, support_index)`, where `support_index` is the number of the support you want to examine.

```{r}
# Inspect the third support
summary_support(result, 3)
```

This allows to explore how variable selection varies across different supports visited by the algorithm and to better understand the model selection process.

## Diagnostic plots

Visual diagnostics can help evaluate the algorithm's variable selection process.

```{r saemvs_plot}
plot(result, type = "criterion")
plot(result, type = "coefficients")[[1]]
```

# Advanced statistical options

## Considering models with fixed-effects

In some situations, one or more parameters are not assumed to vary between individuals, but are instead modeled as fixed effects.
In `saemvs`, this can be specified using the argument `phi_fixed` in the `saemvsModel` constructor.

In the example below, parameter `b` is treated as a fixed effect:

- Fixed effects cannot be subject to variable selection (`phi_fixed` must be disjoint from `phi_to_select`).
- When defining the initial values in `saemvsInit`, the corresponding variance in the random-effects covariance matrix (`cov_re`) must be set to 0. This indicates that this parameter does not vary between individuals.
- The intercept is still initialized in `intercept`.

```{r}
model_fe <- saemvsModel(
  g = g,
  phi_to_select = c("a", "c"),
  phi_fixed = c("b")
)

init_values_fe <- saemvsInit(
  intercept = c(1300, 350, 250),
  beta_candidates = matrix(
    c(
      80, 20, 20, rep(0, 47),
      rep(0, 50),
      15, 0, 5, rep(0, 47)
    ),
    ncol = 3
  ),
  cov_re = diag(c(400, 0, 200)),
  sigma2 = 100
)
```

```{r run_saemvs_fixed_effects, eval = FALSE}
# Run the SAEMVS algorithm
result_with_fixed_effects <- saemvs(
  data = saemvs_input,
  model = model_fe,
  init = init_values_fe,
  tuning_algo = tuning,
  hyperparam = hyper_slab
)
```

```{r load_results_wfe, include = FALSE}
result_with_fixed_effects <- readRDS(
  system.file(
    "extdata", "result_with_fixed_effects.rds", package = "saemvs"
  )
)
```

```{r results_saemvs_fixed_effects}
summary(result_with_fixed_effects)
```

## Forcing inclusion of variables

In some applications, it is necessary to force the inclusion of certain covariates in the model, regardless of their statistical support in the selection procedure. For example, one may want to always adjust for a baseline covariate such as treatment group or sex, while allowing other covariates to be selected or discarded.

With the `saemvsData_from_df()` interface, forced covariates are specified directly in the formula using a `+` sign:

```{r}
saemvs_input_fc <- saemvsData_from_df(
  formula = as.formula("y ~ + x1  + repeated(time) + group(id)"),
  data = full_data
)
```

Here:

- `+ x1` indicates that the covariate named `x1` is forced to be included in the model.
- `repeated(time)` and `group(id)` work as before to indicate repeated measurements and individual identifiers.
- The other covariates in the dataset are subject to the variable selection procedure.

You still need to specify which model parameters are affected by the forced covariates and provide initial values:

```{r}
model_with_fc <- saemvsModel(
  g = g,
  phi_to_select = c("a", "c"),
  x_forced_support = list(
    a = c("x1"),
    c = c("x1")
  )
)

init_values_fc <- saemvsInit(
  intercept = c(1300, 350, 250),
  beta_candidates = matrix(
    c(
      20, 20, rep(0, 47),
      rep(0, 49),
      0, 5, rep(0, 47)
    ),
    ncol = 3
  ),
  beta_forced = matrix(
    c(80, 0, 15),
    ncol = 3, nrow = 1
  ),
  cov_re = diag(c(400, 200, 200)),
  sigma2 = 100
)
```

- `x_forced_support` indicates which parameters the forced covariate affects.

- `beta_forced` provides initial values for the coefficients of the forced covariates.

```{r run_saemvs_forced_covariates, eval= FALSE}
result_with_forced_covariates <- saemvs(
  data = saemvs_input_fc,
  model = model_with_fc,
  init = init_values_fc,
  tuning_algo = tuning,
  hyperparam = hyper_slab
)
```

```{r load_results_wfc, include = FALSE}
result_with_forced_covariates <- readRDS(
  system.file(
    "extdata", "result_with_forced_covariates.rds", package = "saemvs"
  )
)
```

```{r result_with_forced_covariates}
summary(result_with_forced_covariates, digits = 3)
```

# Technical options for computation

For high-dimensional applications or fine control over convergence, the package provides technical options such as parallel computing. Some computations are implemented in C++ via Rcpp for efficiency, but it is also possible to switch to a full R implementation if desired or if the system configuration does not allow C++ compilation. Please refer to the package documentation for full details on these options.
